 PDF To Markdown Converter
Debug View
Result View
```
Trabalho em grupo 2 - Valor 10 pontos
```
```
INFORMAÃ‡Ã•ES DOCENTE
CURSO:
ENGENHARIA DE SOFTWARE
```
```
DISCIPLINA:
FUNDAMENTOS DE PROJETO E
ANÃLISE DE ALGORITMOS
```
```
TURNO
```
**MANHÃƒ TARDE NOITE** (^) **PERÃODO/SALA:
x**^5 Âº^
**PROFESSOR (A): JoÃ£o Paulo Carneiro Aramuni**
Enunciado do projeto: **FloodFill - Colorindo regiÃµes de um terreno com obstÃ¡culos**
Contexto:
Â§ Sua equipe foi contratada por uma empresa de automaÃ§Ã£o para desenvolver um
sistema de mapeamento inteligente para robÃ´s autÃ´nomos que precisam
identificar e classificar regiÃµes de um terreno previamente desconhecido.
Â§ O terreno Ã© representado como um grid bidimensional, onde cada cÃ©lula pode ser
um espaÃ§o livre ou um obstÃ¡culo. AlÃ©m disso, diferentes Ã¡reas do terreno podem
ser separadas por barreiras, formando regiÃµes desconectadas.
Â§ O sistema deve identificar e "colorir" automaticamente todas as Ã¡reas livres
conectadas, de forma a facilitar a visualizaÃ§Ã£o e o planejamento do robÃ´ para
executar suas operaÃ§Ãµes.
Objetivo:
Â§ Implementar o Algoritmo Flood Fill para identificar e preencher
automaticamente todas as regiÃµes conectadas em um grid 2D, utilizando
diferentes cores para cada Ã¡rea.
Â§ O algoritmo deve respeitar os obstÃ¡culos presentes no terreno e evitar colidir
com eles.
Â§ O programa tambÃ©m deve ser capaz de localizar novas Ã¡reas livres
automaticamente apÃ³s preencher uma regiÃ£o, continuando o processo atÃ© que
todo o terreno esteja mapeado e colorido.
DescriÃ§Ã£o do problema:
Â§ VocÃª receberÃ¡ um grid bidimensional ğ‘› Ã— ğ‘š, onde cada cÃ©lula pode conter um
dos seguintes valores:
o 0: Terreno navegÃ¡vel (regiÃµes que podem ser preenchidas - branco).
o 1: ObstÃ¡culo (nÃ£o navegÃ¡vel, deve ser ignorado pelo preenchimento -
**preto** ).
o 2, 3, 4, ...: Cores jÃ¡ preenchidas em outras regiÃµes ( **vermelho** , **laranja** ,
**amarelo** , etc.).


```
Â§ AlÃ©m disso, serÃ¡ fornecida uma cÃ©lula inicial (ğ‘¥, ğ‘¦), de onde o preenchimento
comeÃ§arÃ¡.
Â§ O algoritmo deve:
o I. Determinar todas as cÃ©lulas conectadas Ã  cÃ©lula inicial que possuem o
valor 0.
o II. Substituir o valor 0 dessas cÃ©lulas por um valor de cor especÃ­fico (ex.:
2 para a primeira regiÃ£o preenchida, 3 para a prÃ³xima, e assim por
diante).
```
Requisitos do programa:

1. Entrada:
    Â§ DimensÃµes do grid ğ‘› Ã— ğ‘š.
    Â§ O grid em si, com os valores 0, 1, e, opcionalmente, cores jÃ¡ preenchidas.
    Â§ Coordenadas iniciais (ğ‘¥, ğ‘¦) para o preenchimento.
2. SaÃ­da:
    Â§ O grid atualizado, com a regiÃ£o conectada Ã  cÃ©lula inicial preenchida pela cor
       fornecida.
3. Regras:
    Â§ O preenchimento deve respeitar os obstÃ¡culos (cÃ©lulas com valor 1) e nÃ£o pode
       ultrapassÃ¡-los.
    Â§ RegiÃµes jÃ¡ coloridas (valores acima de 1) devem ser mantidas intactas.
    Â§ A regiÃ£o conectada Ã© composta apenas por cÃ©lulas navegÃ¡veis (0) adjacentes
       ortogonalmente (acima, abaixo, Ã  esquerda e Ã  direita).
    Â§ ApÃ³s o preenchimento de uma regiÃ£o, o programa deve localizar
       automaticamente a prÃ³xima cÃ©lula navegÃ¡vel (0) e preencher uma nova regiÃ£o
       com uma cor diferente (incrementando o valor da cor: 2, 3, 4, ...).
    Â§ O processo deve continuar atÃ© que todas as cÃ©lulas navegÃ¡veis tenham sido
       preenchidas.
4. DocumentaÃ§Ã£o no README.md:
    - Crie um arquivo README.md contendo a descriÃ§Ã£o do projeto, uma introduÃ§Ã£o
       sobre o problema resolvido (identificaÃ§Ã£o e preenchimento de regiÃµes
       conectadas em um grid 2D com o Algoritmo Flood Fill), as instruÃ§Ãµes
       necessÃ¡rias para configurar e executar o projeto, e uma explicaÃ§Ã£o clara sobre o
       funcionamento do Algoritmo Flood Fill implementado.
    - Destaque como o algoritmo percorre o grid a partir de uma cÃ©lula inicial,
       identifica cÃ©lulas navegÃ¡veis conectadas, e as preenche com uma cor especÃ­fica,
       respeitando obstÃ¡culos e limites do grid.


- Certifique-se de incluir exemplos claros de entrada e saÃ­da para ilustrar o
    funcionamento do projeto, utilizando grids de diferentes tamanhos e
    configuraÃ§Ãµes. As representaÃ§Ãµes visuais devem incluir um grid inicial, com
    terrenos navegÃ¡veis e obstÃ¡culos, e o grid final, com regiÃµes preenchidas em
    cores distintas.

Exemplo 1 :

Entrada:
Grid inicial:
0 0 1 0 0
0 1 1 0 0
0 0 1 1 1
1 1 0 0 0

Coordenadas iniciais: (0, 0)

SaÃ­da:
Grid preenchido:
2 2 1 3 3
2 1 1 3 3
2 2 1 1 1
1 1 4 4 4

Exemplo 2 :

Entrada:
Grid inicial:
0 1 0 0 1
0 1 0 0 1
0 1 1 1 1
0 0 0 1 0
Coordenadas iniciais: (0, 2 )

SaÃ­da:
Grid preenchido:
3 1 2 2 1
3 1 2 2 1
3 1 1 1 1
3 3 3 1 4


Ponto extra (Opcional):
Â§ Adicionar uma interface grÃ¡fica simples que mostre o grid sendo preenchido
dinamicamente.
Â§ Gerar automaticamente grids aleatÃ³rios com diferentes proporÃ§Ãµes de terrenos
navegÃ¡veis e obstÃ¡culos.

VisualizaÃ§Ã£o com cores:

Exemplo 1 :
Entrada:
Grid inicial:
0 0 **1** 0 0
0 **1 1** 0 0
0 0 **1 1 1
1 1** 0 0 0
Coordenadas iniciais: (0, 0)

SaÃ­da:
Grid preenchido:
2 2 **1** 3 3
2 **1 1** 3 3
2 2 **1 1 1
1 1** 4 4 4

```
Entrada SaÃ­da
```
Legenda:
0 â€“ Branco (Terreno navegÃ¡vel)
1 â€“ Preto (ObstÃ¡culo)
2 â€“ Vermelho
3 â€“ Laranja
4 â€“ Amarelo


Entrega:
Â§ O projeto deverÃ¡ ser enviado por meio de um repositÃ³rio no GitHub, com o link
postado no sistema CANVAS. Certifique-se de que o repositÃ³rio esteja pÃºblico
ou acessÃ­vel (antes de realizar a entrega, faÃ§a um teste em uma aba anÃ´nima do
navegador).
Â§ Preferencialmente, todos os integrantes do grupo entregam o link do repositÃ³rio
do trabalho no CANVAS. Isto Ã© Ãºtil para que o registro de entrega fique salvo
em cada usuÃ¡rio.
Â§ Exemplo de link a ser entregue no CANVAS:
o https://github.com/exemploaluno/trabalho_em_grupo_2_FPAA

CritÃ©rios de avaliaÃ§Ã£o:

1. Corretude: O algoritmo deve preencher as regiÃµes corretamente, respeitando os
obstÃ¡culos e delimitadores.
2. EficiÃªncia: SoluÃ§Ãµes recursivas e iterativas serÃ£o avaliadas quanto Ã  eficiÃªncia em
grids grandes.
3. VisualizaÃ§Ã£o - A soluÃ§Ã£o deve apresentar o grid antes e depois do preenchimento, em
duas versÃµes:
    Â§ VersÃ£o de terminal: No formato impresso de matriz (utilizando nÃºmeros, 0, 1, 2,
       3, 4, etc. para as linhas e colunas).
    Â§ VersÃ£o grÃ¡fica: Colorida, conforme mostrado na _VisualizaÃ§Ã£o com cores_ do
       Exemplo 1.

DistribuiÃ§Ã£o de pontos:

1. ImplementaÃ§Ã£o do Algoritmo (50%):
    Â§ O cÃ³digo estÃ¡ correto e eficiente?
    Â§ A lÃ³gica para identificar e preencher regiÃµes conectadas, por meio do Algoritmo
       Flood Fill, foi seguida adequadamente?
    Â§ O algoritmo Ã© capaz de lidar corretamente com diferentes entradas, como grids
       grandes, grids com mÃºltiplos obstÃ¡culos e grids sem cÃ©lulas navegÃ¡veis?
    Â§ O cÃ³digo possui clareza, estÃ¡ organizado e segue boas prÃ¡ticas de programaÃ§Ã£o?
2. DocumentaÃ§Ã£o no README.md (50%):
    Â§ O README segue o padrÃ£o especificado?
    Â§ A documentaÃ§Ã£o fornece instruÃ§Ãµes claras para configurar e executar o projeto?
    Â§ A explicaÃ§Ã£o do Algoritmo Flood Fill estÃ¡ detalhada e compreensÃ­vel,
       destacando como o algoritmo identifica regiÃµes conectadas e as preenche com
       cores distintas, respeitando os obstÃ¡culos?
    Â§ O README contÃ©m exemplos claros de entrada e saÃ­da para ilustrar o
       funcionamento do projeto?
    Â§ As informaÃ§Ãµes sÃ£o suficientes para que qualquer pessoa possa entender e
       utilizar o projeto sem dificuldades?



This is a offline tool, your data stays locally and is not send to any server!
Feedback & Bug Reports